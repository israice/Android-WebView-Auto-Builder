import os
import subprocess
import threading
import time
import uuid
import random
from flask import Flask, render_template, request, jsonify, send_file, after_this_request

app = Flask(__name__)

# Configuration
CORE_DIR = os.path.join(os.getcwd(), 'CORE')
OUTPUT_DIR = os.path.join(os.getcwd(), 'FINISHED_HERE')

BUILD_SCRIPT = os.path.join(CORE_DIR, 'linux_mac_build_apk.sh')

# Global state to track jobs
jobs = {}



from CORE.ultra_fast_builder import UltraFastBuilder

# Initialize Fast Builder
fast_builder = UltraFastBuilder(CORE_DIR)

# Start preparation in background
def prepare_builder():
    try:
        print("Initializing Ultra Fast APK Builder environment...")
        fast_builder.prepare_environment()
        print("Ultra Fast APK Builder ready!")
    except Exception as e:
        print(f"Failed to initialize builder: {e}")

threading.Thread(target=prepare_builder).start()

def run_build(job_id, apk_name, url):
    jobs[job_id]['status'] = 'running'
    jobs[job_id]['progress'] = 0
    
    # Ensure apk_name ends with .apk
    if not apk_name.endswith('.apk'):
        apk_name += '.apk'
        
    jobs[job_id]['filename'] = apk_name

    def update_progress(p):
        jobs[job_id]['progress'] = p

    try:
        # Use the fast builder
        print(f"Starting build for {apk_name} ({url})")
        output_path = fast_builder.build(url, apk_name, job_id, progress_callback=update_progress)
        
        if os.path.exists(output_path):
            jobs[job_id]['status'] = 'completed'
            jobs[job_id]['progress'] = 100
        else:
            raise Exception("Output file not found")
            
    except Exception as e:
        print(f"Build error: {e}")
        jobs[job_id]['status'] = 'failed'
        jobs[job_id]['error'] = str(e)

def delete_file_later(filepath, delay=3):
    def delayed_delete():
        time.sleep(delay)
        try:
            if os.path.exists(filepath):
                os.remove(filepath)
                print(f"Deleted {filepath}")
            
            # Also delete the .idsig file generated by apksigner
            idsig_path = filepath + ".idsig"
            if os.path.exists(idsig_path):
                os.remove(idsig_path)
                print(f"Deleted {idsig_path}")
        except Exception as e:
            print(f"Error deleting {filepath}: {e}")
            
    threading.Thread(target=delayed_delete).start()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/create', methods=['POST'])
def create():
    data = request.json
    apk_name = data.get('apk_name')
    url = data.get('url')
    
    if not apk_name or not url:
        return jsonify({'error': 'Missing parameters'}), 400
        
    job_id = str(uuid.uuid4())
    jobs[job_id] = {
        'status': 'pending',
        'apk_name': apk_name,
        'url': url,
        'start_time': time.time()
    }
    
    thread = threading.Thread(target=run_build, args=(job_id, apk_name, url))
    thread.start()
    
    return jsonify({'job_id': job_id})

@app.route('/status/<job_id>')
def status(job_id):
    job = jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
        
    response = {
        'status': job['status'],
        'progress': job.get('progress', 0)
    }
    
    if job['status'] == 'completed':
        response['download_url'] = f"/download/{job['filename']}"
        
    return jsonify(response)

@app.route('/download/<filename>')
def download(filename):
    filepath = os.path.join(OUTPUT_DIR, filename)
    
    if not os.path.exists(filepath):
        # Fallback to project root if not in OUTPUT_DIR (just in case script behavior changes)
        filepath = os.path.join(os.getcwd(), filename)
        
    if not os.path.exists(filepath):
        return "File not found", 404

    # Schedule deletion
    delete_file_later(filepath)
    
    return send_file(filepath, as_attachment=True)

if __name__ == '__main__':
    # Ensure output directory exists
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
        
    app.run(host='0.0.0.0', port=5001)
